---
author: micdemarco
comments: true
date: 2014-11-05 14:07:35+00:00
layout: post
link: https://micdemarco.wordpress.com/2014/11/05/unit-testing-with-entity-framework/
slug: unit-testing-with-entity-framework
title: Unit Testing With Entity Framework
wordpress_id: 3
---

While working on a project involving Integration between Web Services and an MsSQL Database accessed through Entity Framework, I decided to use a Test Driven Approach.

At first I used a direct reference to my data model and wrote integration tests, however this required that all my tests depend upon having a database up and running to connect to.

I wanted to have my tests written to be independent of the Database.  In order to do this I followed the following steps adapted from an [excellent post by Tom FitzMacken](http://www.asp.net/web-api/overview/testing-and-debugging/mocking-entity-framework-when-unit-testing-aspnet-web-api-2):


### 1) Create an interface from your DataContext - IAppDataModel


Create an interface IAppDataModel and extract all DbSet members and SaveChanges:

{% gist micdemarco/7cf17ed7ae9b77aac852 %}
**Listing 1: Interface from your DbContext**

**Tip**: To remove coupling, place the interface in a separate project named Solution.RepositoryInterfaces


### 2) Change your DbContext to implement the interface IAppDataModel


{% gist micdemarco/28f9b6b76ef69289027b %}
**Listing 2: Implement the interface on your DbContext**


### 3) Change your Business Classes to use the interface IAppDataModel


{% gist micdemarco/0606e3cb72252b80e2a1 %}
**Listing 3: Use an interface instead of a direct reference to your DbContext**

By using an interface, you can choose what implementation you want to pass to the business class depending on your context.  For the test project, you will pass a Test DbContext.  At runtime you will an instance of your EF DbContext.


### 4) In your test project add a TestDbSet class


Add a class that inherits from DbSet and implements IQueryable and IEnumerable

{% gist micdemarco/628e1fdab11a3f2f55a6 %}
**Listing 4: TestDbSet Class**


### 5) Create a Test DbContext that implements your IAppDataModel


{% gist micdemarco/bc18feac17ec3fed6c1d %}
**Listing 5: Creating a Test DbContext with a Seed method**


### 6) Use the Test DbContext in the tests


{% gist micdemarco/fe35731e1b550c52d84b %}
**Listing 6: Using the TestDbContext**


### 7) Optional - Create a DbSet that generates Identity


After implementing the Test DbContext, I realised that some of my tests were broken because they required an Identity Primary Key to be generated from the database.

In order to get around this I implemented a specially derived class with an overridden Create method for every Entity that required an Identity to be generated by the database:

{% gist micdemarco/f289176252e39af0939e %}
**Listing 7: Inheriting from TestDbSet and overriding Create method**


## Conclusion


By defining an interface for your DbContext, it is possible to create an in memory Database Context that implements the same interface and can be used to simulate the physical Database.  This allows you to write Unit Tests that manipulate the Database Context without needing to connect to a physical Database.  While this is great for Unit Testing it must not be assumed that the simulated database will behave exactly as the physical database, and you will still need to perform Integration tests in order to know for certain that your code executes correctly.

For more information and a downloadable project check the [post by Tom FitzMacken](http://www.asp.net/web-api/overview/testing-and-debugging/mocking-entity-framework-when-unit-testing-aspnet-web-api-2).
